{
    public:
    //Function to find the maximum money the thief can get.
    int FindMaxSum(int arr[], int n)
    {
        //storing sum up to current element including and 
        //excluding it in respective variables.
        int incl_curr = arr[0]; 
        int excl_curr = 0; 
        
        //storing sum up to previous element including and 
        //excluding it in respective variables.
        int incl_prev = incl_curr; 
        int excl_prev = excl_curr; 
        
        for (int i = 1; i < n; i++)
        {
            //updating sum up to current element excluding it as maximum
            //of sum upto previous element excluding and including it.
            excl_curr = max(incl_prev, excl_prev); 
            
            //updating sum up to current element including it as sum up to 
            //previous element excluding it + current element.
            incl_curr = excl_prev + arr[i]; 
            
            //updating sum upto previous element including and 
            //excluding it for next iteration.
            excl_prev = excl_curr;  
            incl_prev = incl_curr; 
        }
        
        //returning the maximum of sum up to current element  
        //including and excluding it.
        return max(excl_curr, incl_curr);
    }
};



METHOD SAME 

#include <bits/stdc++.h>
using namespace std;

// Function to return max sum such that 
// no two elements are adjacent 
int FindMaxSum(vector<int> arr, int n)
{
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        // Current max excluding i
        excl_new = max(incl, excl);

        // Current max including i
        incl = excl + arr[i];
        excl = excl_new;
    }

    // Return max of incl and excl
    return max(incl, excl);
}

// Driver code
int main()
{
    vector<int> arr = { 5, 5, 10, 100, 10, 5 };
    int N = arr.size();

    // Function call
    cout << FindMaxSum(arr, N);
    return 0;
}
// This approach is contributed by Debanjan